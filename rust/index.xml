<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rust on 奇风岁月</title><link>https://travisbikkle.github.io/rust/</link><description>Recent content in rust on 奇风岁月</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>Copyright © 2022-{year} Travis Bikkle. All Rights Reserved.</copyright><lastBuildDate>Fri, 23 Aug 2024 17:32:12 +0800</lastBuildDate><atom:link href="https://travisbikkle.github.io/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>OS 开发备忘3</title><link>https://travisbikkle.github.io/2024/08/osdev-memo3/</link><pubDate>Fri, 23 Aug 2024 17:32:12 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/osdev-memo3/</guid><description>多任务 Preemptive Multitasking 抢占式多任务 核心思想是操作系统控制什么时候切换任务。
第一行中，CPU 正在执行程序 A 的任务 A1。在第二行中，CPU 收到一个硬件中断。如硬件中断一文所述， CPU 会立即停止执行任务 A1，并跳转到中断描述符表 (IDT) 中定义的中断处理程序。通过该中断处理程序， 操作系统现在可以再次控制 CPU，从而切换到任务 B1，而不是继续执行任务 A1。
保存状态 由于任务会在任意时间点被中断，它们可能正在进行某些计算。为了能在稍后恢复任务，操作系统必须备份任务的整个状态， 包括其调用堆栈（call stack）和所有 CPU 寄存器（cpu register）的值。这个过程称为上下文切换（context switch）。
由于调用堆栈可能非常庞大，操作系统通常会为每个任务建立单独的调用堆栈，而不是在每个任务切换时备份调用堆栈内容。 这种拥有自己堆栈的任务称为执行线程（thread of execution），简称线程（thread）。 通过为每个任务使用单独的堆栈，在上下文切换时只需保存寄存器内容（包括程序计数器和堆栈指针）。 这种方法最大限度地减少了上下文切换的性能开销，这一点非常重要，因为上下文切换通常每秒会发生 100 次。
优缺点 优点：
操作系统保证 cpu 分配时间公平 缺点：
每个程序需要保存单独的 stack，浪费内存 操作系统需要为每次切换保存 cpu register 状态，即使任务只用了很少一部分 register Cooperative Multitasking 协作式多任务 核心思想是程序可以主动交出 cpu 控制权。
保存状态 由于任务自己定义暂停点，因此它们不需要操作系统来保存状态。 相反，它们可以在自己暂停之前准确保存继续运行所需的状态，这通常会带来更好的性能。 例如，Rust 的 async/await 实现会将所有仍需使用的局部变量存储在自动生成的结构体中（见下文）。
通过在暂停前备份调用栈的相关部分，所有任务都可以共享一个调用栈，从而大大降低了每个任务的内存消耗。这样就可以创建几乎任意数量的任务，而不会耗尽内存。
优缺点 优点：
性能高 缺点：
一些任务可能占有全部资源，其它任务获取不到 cpu 时间 rust 中的 async/await Future Future 代表一个现在还不能用的值。</description></item><item><title>OS 开发备忘2</title><link>https://travisbikkle.github.io/2024/08/osdev-memo2/</link><pubDate>Tue, 20 Aug 2024 17:32:12 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/osdev-memo2/</guid><description>实现堆内存 本地变量与栈内存 outer 方法调用 inner 方法的栈，从上至下。 inner 方法执行完成后。 静态变量 静态变量存储在独立于堆栈的固定内存位置。
该内存位置在编译时由链接器分配，并在可执行文件中编码。
动态内存 本地变量只生存于作用域内，静态变量全局可用、不能够回收、所有权不清晰。
两者都有一个固定的大小，所以无法存储会动态增长的变量。
为了解决这些问题，编程语言都会引入第三块内存区域： heap。
假设使用 allocate 和 deallocate 来分配和释放内存：
在调用 deallocate 之后，内存变成如下图所示：
所以相对于静态变量来说，z[1] 这块内存区域，我们可以复用。
但是 z[0] 和 z[2] 永远不释放，这就造成了内存泄漏。
其它错误 除了内存泄漏，但它并不会使我们的程序更易受到攻击，还有两种类型的错误会有更严重的后果：
use-after-free: 在 deallocate 之后尝试使用这个变量，这种错误会导致无法预料的行为，经常被攻击者利用来执行任意代码。 double-free: 释放两次，可能会释放掉一个在 deallocate 之后又重新分配的地址，也有可能导致 use-after-free 问题。 即使是最好的程序员，也无法永远不出错误地处理这些分配和释放流程，而且每年都会有新的错误， 比如可以在搜索引擎尝试搜索 use-after-free 2024，你可以把 2024 换成当年的年份。
为了解决这些问题，java 和 python 会使用垃圾回收机制，核心思想是，编码者无需手动写 allocate 和 deallocate，而是定时暂停、 扫描程序中未使用的堆变量，然后释放掉这些内存。这样，以上错误就不会再出现，缺点是定时扫描导致的性能开销，以及长时间的暂停。
rust 使用了不一样的解决方法：它使用所有权设计，来在编译时检查动态内存操作的正确性，于是rust消灭了垃圾回收，当然也就没有性能开销了。 另一个好处是，编码者仍然对内存拥有细粒度的控制，就像 C、C++，缺点就是你会有很多编译错误需要解决。
rust 中的分配 Rust 中最重要的类型之一是 Box，它其实是堆变量的封装，使用 Box::new 接收一个变量，执行 allocate 分配一个变量大小的区域，然后将变量 的值转移到堆中。要释放这块区域，Box 中还有 Drop 特质，它会调用 deallocate。</description></item><item><title>Rust 错误码 E0277</title><link>https://travisbikkle.github.io/2024/08/2024-08-15-e0277/</link><pubDate>Thu, 15 Aug 2024 11:22:03 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/2024-08-15-e0277/</guid><description>我遇到的错误 直接使用 Error，没有使用 dyn 1fn run(config: Config) -&amp;gt; Result&amp;lt;(), dyn std::error::Error&amp;gt; { 2 let contents = std::fs::read_to_string(config.file_path).expect( 3 ... 4 Ok(()) 官方解释，是你要求返回一个实现了某特质的对象，但是该对象并没有实现该特质。
You tried to use a type which doesn&amp;rsquo;t implement some trait in a place which expected that trait.
其实编译器给出的报错比较接近：
1error[E0277]: the size for values of type `(dyn std::error::Error + &amp;#39;static)` cannot be known at compilation time 2 --&amp;gt; src/main.rs:18:27 3 | 418 | fn run(config: Config) -&amp;gt; Result&amp;lt;(), dyn std::error::Error&amp;gt; { 5 | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn&amp;#39;t have a size known at compile-time 它说，dyn std::error::Error 的大小在编译器无法确定，因此我们可以使用 Box 包裹起来。</description></item><item><title>Rust 错误码 E0283</title><link>https://travisbikkle.github.io/2024/08/2024-08-15-e0283/</link><pubDate>Thu, 15 Aug 2024 11:22:03 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/2024-08-15-e0283/</guid><description>1let args = env::args().collect(); // error 编译器无法推断类型，要求提供类型注解。
错误代码示例:
1let x = &amp;#34;hello&amp;#34;.chars().rev().collect(); 该错误表明编译器无法推断出类型，或者可能有多个类型，需要额外的信息。 在大多数情况下可以通过添加类型注解来提供。有时您需要手动指定一个通用类型参数。
一个常见的例子是 Iterator 上的 collect 方法。它有一个通用类型 参数，对于一个 char 迭代器来说，该参数是由 Vec 和 Name 实现的。 和 String 等实现。请看以下将字符串中的字符反转的示例:
在第一个代码示例中，编译器无法推断出 x 的类型应该是应该是什么类型: Vec&amp;lt;char&amp;gt;和String都是合适的候选类型。要指定使用哪种类型，可以在 x 上使用类型注解:
1let x: Vec&amp;lt;char&amp;gt; = &amp;#34;hello&amp;#34;.chars().rev().collect(); 无需注释完整类型。一旦解决了模棱两可的问题，编译器就能推断出其余部分:
1let x: Vec&amp;lt;_&amp;gt; = &amp;#34;hello&amp;#34;.chars().rev().collect(); 另一种为编译器提供足够信息的方法是指定通用类型参数:
1let x = &amp;#34;hello&amp;#34;.chars().rev().collect::&amp;lt;Vec&amp;lt;char&amp;gt;&amp;gt;(); 同样，如果编译器能推断出完整类型，则无需指定:
1let x = &amp;#34;hello&amp;#34;.chars().rev().collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;(); 我们可以看到下面一个独立的示例:
1struct Foo; 2 3impl Into&amp;lt;u32&amp;gt; for Foo { 4 fn into(self) -&amp;gt; u32 { 1 } 5} 6 7let foo = Foo; 8let bar: u32 = foo.</description></item><item><title>Rust 错误码 E0507</title><link>https://travisbikkle.github.io/2024/08/2024-08-15-e0507/</link><pubDate>Thu, 15 Aug 2024 11:22:03 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/2024-08-15-e0507/</guid><description>1	let args: Vec&amp;lt;_&amp;gt; = env::args().collect(); 2	let query = args[1]; // error move = take ownership = 取得所有权。
borrow = don't take ownership = 借用。
move 常见案例 1// _Stack_ 分配的变量 2let x = 5u32; 3// *Copy* `x` 到 `y` - 所有权未发生转移，未发生 move 4let y = x; 5// 两个变量可以同时使用 6println!(&amp;#34;x is {}, and y is {}&amp;#34;, x, y); 7 8// `a` 是指向 _heap_ 上分配的变量的 pointer 9let a = Box::new(5i32); 10 11println!</description></item><item><title>OS 开发备忘</title><link>https://travisbikkle.github.io/2024/08/osdev-memo/</link><pubDate>Wed, 07 Aug 2024 17:32:12 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/osdev-memo/</guid><description>显示（VGA TEXT MODE） 要在 VGA 文本模式下将字符打印到屏幕上，必须将其写入 VGA 硬件的文本缓冲区。 VGA 文本缓冲区是一个二维数组，通常有 25 行 80 列，可直接渲染到屏幕上。 每个数组条目通过以下格式描述一个屏幕字符： Bit(s) Value 0-7 ASCII 字符，8bit 8-11 前景色，4bit 12-14 背景色，3bit 15 闪烁，1bit 如何设计（伪代码）： 1#[derive(Debug, Clone, Copy, PartialEq, Eq)] 2#[repr(u8)] 3pub enum Color { 4 Black = 0, 5 Blue = 1, 6 Green = 2, 7 // 蓝绿 8 Cyan = 3, 9 Red = 4, 10 // 洋红 11 Magenta = 5, 12 Brown = 6, 13 LightGray = 7, 14 DarkGray = 8, 15 .</description></item></channel></rss>