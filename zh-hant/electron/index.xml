<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>electron on 奇风岁月</title><link>https://travisbikkle.github.io/zh-hant/electron/</link><description>Recent content in electron on 奇风岁月</description><generator>Hugo -- gohugo.io</generator><language>zh-hant</language><copyright>Copyright © 2022-{year} Travis Bikkle. All Rights Reserved.</copyright><lastBuildDate>Mon, 01 Jul 2024 10:18:30 +0800</lastBuildDate><atom:link href="https://travisbikkle.github.io/zh-hant/electron/index.xml" rel="self" type="application/rss+xml"/><item><title>Aria2 Rpc 使用</title><link>https://travisbikkle.github.io/zh-hant/2024/07/aria2-rpc/</link><pubDate>Mon, 01 Jul 2024 10:18:30 +0800</pubDate><guid>https://travisbikkle.github.io/zh-hant/2024/07/aria2-rpc/</guid><description>本文將演示如何使用 aria2 rpc 開發一個下載模塊，注意，這不是一個完整的應用，僅僅是爲了給你一些啓發。
tech version electron 30.0.6 webpack 5.91.0 nodejs v20.14.0 aria2 1.37.0 React 18.2.0 react-use-websocket 4.8.1 @mui/x-charts/SparkLineChart 7.3.2 aria2 文檔 react-use-websocket 文檔
成品演示 加載並啓動 aria2 怎麼將 aria2 集成到你的項目中 你可以要求你的用戶自行安裝 aria2c.exe，或者將 aria2c.exe 直接打包到你的項目中。
如果你採用後者，下面是一些示例。
假設你的工程目錄是：
1src 2build 3 |-- aria2c.exe 4package.json 打包 下面是一個使用 Electron Builder 的示例，它將 build/aria2c.exe 拷貝到安裝後的根目錄。
1&amp;#34;scripts&amp;#34;: { 2 &amp;#34;dev&amp;#34;: &amp;#34;xxxxxxx&amp;#34; 3}, 4&amp;#34;build&amp;#34;: { 5 &amp;#34;extraFiles&amp;#34;: [ 6 { 7 &amp;#34;from&amp;#34;: &amp;#34;build/aria2c.exe&amp;#34;, 8 &amp;#34;to&amp;#34;: &amp;#34;&amp;#34; 9 }, 10} 將它放到 package.</description></item><item><title>Electron 源碼保護</title><link>https://travisbikkle.github.io/zh-hant/2024/06/electron-bytecode/</link><pubDate>Sat, 29 Jun 2024 10:15:44 +0800</pubDate><guid>https://travisbikkle.github.io/zh-hant/2024/06/electron-bytecode/</guid><description>這是一個示例，演示如何快速在你的 Electron 項目中啓用字節碼保護，沒有多餘的廢話。
環境 tech version electron 30.0.6 webpack 5.91.0 @herberttn/bytenode-webpack-plugin 2.3.1 nodejs v20.14.0 步驟 Webpack 配置 參考文檔
1// 引入依賴 2const { BytenodeWebpackPlugin } = require(&amp;#39;@herberttn/bytenode-webpack-plugin&amp;#39;); 3// 在生產環境啓用 4const isEnvProduction = process.env.NODE_ENV === &amp;#39;production&amp;#39;; 5... 6plugins: [ 7 isEnvProduction &amp;amp;&amp;amp; new BytenodeWebpackPlugin({ compileForElectron: true }), 8], 9... 10// main，preload，renderer 需要更改 entry 配置。我使用了 webpack-merge，如果你沒有使用，忽略即可。 11// main 12const mainConfig = merge(commonConfig, { 13 // entry: &amp;#39;./src/main/main.ts&amp;#39;, 14 entry: { 15 main: &amp;#39;./src/main/main.ts&amp;#39;, 16 }, 17 target: &amp;#39;electron-main&amp;#39;, 18 output: { 19 filename: &amp;#39;[name].</description></item><item><title>electron-log@5 的使用</title><link>https://travisbikkle.github.io/zh-hant/2024/05/2024-05-17-electron-log-v5/</link><pubDate>Fri, 17 May 2024 18:21:53 +0800</pubDate><guid>https://travisbikkle.github.io/zh-hant/2024/05/2024-05-17-electron-log-v5/</guid><description>我們使用一個開源軟件，一般都是通過搜索示例或教程來學習如何使用。可是如果一個軟件發生過不兼容的變更，而網絡上一般都是些舊的做法，這樣就會給我們帶來非常大的心智負擔。
因此我建議有志之士儘量去看官方文檔，即使它可能是英語，或者沒有太好的示例，仍然要去看，而不是被一些沒頭沒尾或者抄來抄去的博客耽誤你的時間。
Electron 的官方文檔就非常得不詳細，它也在 main，preload，renderer 這一塊變過很多次，詳情可以看看博客中的上一篇文章《在 webapck+electron+typescript中使用go開發的node插件》。
本文說說一個常用的日誌小工具 electron-log 的使用（基於 5.1.4）。
引入 1npm i electron-log 自己定義一個 logger.ts（也可以在 main.ts 中直接定義） 1import log from &amp;#39;electron-log/main&amp;#39;; 2log.transports.console.level = false; // 控制檯關閉輸出（只輸出到文件） 3log.transports.file.level = &amp;#39;silly&amp;#39;; 4log.transports.file.maxSize = 1002430; // 文件最大不超過 1M 5log.transports.file.format = &amp;#39;[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}]{scope} {text}&amp;#39;; 6const date = new Date(); 7const dateStr = date.getFullYear() + &amp;#39;-&amp;#39; + (date.getMonth() + 1) + &amp;#39;-&amp;#39; + date.getDate(); 8log.transports.file.resolvePathFn = () =&amp;gt; &amp;#39;log\\&amp;#39; + dateStr + &amp;#39;.</description></item><item><title>在 webapck+electron+typescript中使用go開發的node插件</title><link>https://travisbikkle.github.io/zh-hant/2024/04/2024-04-23-webpack-electron-node-addon/</link><pubDate>Tue, 23 Apr 2024 18:21:53 +0800</pubDate><guid>https://travisbikkle.github.io/zh-hant/2024/04/2024-04-23-webpack-electron-node-addon/</guid><description>node 插件，electron 和 webpack 那些事 首先要明確在哪裏引入 node 的插件， main，preload還是 renderer？ 我們開發了一個 node 的插件，需要在 electron 中引入。我們一開始當然是希望在 renderer 中引入，畢竟最接近業務邏輯，省事。
不過會遇到報錯 &amp;lsquo;require is not defined&amp;rsquo;，也就是沒有 require 函數。
這個時候網上可能有些回答會讓你在 main.ts 中打開 nodeIntegration：
1mainWindow = new BrowserWindow({ 2 height: 800, 3 width: 1280, 4 maxHeight: 2160, 5 webPreferences: { 6 nodeIntegration: true, 7 devTools: nodeEnv.dev, 8 preload: path.join(__dirname, &amp;#39;./preload.bundle.js&amp;#39;), 9 }, 10}); 實際上這是不推薦的，爲什麼要在 renderer 中允許執行本地的命令，如 fs 等等？如果是一個惡意的網站，他就能訪問你本機所有的文件。當然如果你確保自己的應用不訪問外部網站，也可以。
我們可以瞭解下比較安全的做法。
爲了解決這個問題，我花了整整一天的時間，我這個項目的技術棧是 TypeScript, Webpack 5, 並且需要引入一個 go 寫的 node 插件，現代 javascript 的buff 疊滿了屬於是，我這個後端開發感受到了前端滿滿的惡意了。 開發插件並在 node 中跑通不到兩小時，可是把這個插件放到 webpack + electron 中花了我整整 7 個小時。</description></item></channel></rss>