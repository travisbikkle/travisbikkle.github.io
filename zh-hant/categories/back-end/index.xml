<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Back-End on 奇风岁月</title><link>https://travisbikkle.github.io/zh-hant/categories/back-end/</link><description>Recent content in Back-End on 奇风岁月</description><generator>Hugo -- gohugo.io</generator><language>zh-hant</language><copyright>Copyright © 2022-{year} Travis Bikkle. All Rights Reserved.</copyright><lastBuildDate>Mon, 29 Jul 2024 10:21:11 +0800</lastBuildDate><atom:link href="https://travisbikkle.github.io/zh-hant/categories/back-end/index.xml" rel="self" type="application/rss+xml"/><item><title>怎麼在 Java 中限制用戶訪問頻率</title><link>https://travisbikkle.github.io/zh-hant/2024/07/request-limit/</link><pubDate>Mon, 29 Jul 2024 10:21:11 +0800</pubDate><guid>https://travisbikkle.github.io/zh-hant/2024/07/request-limit/</guid><description>我們當然要限制用戶訪問頻率，因爲用戶可能生氣，並狂點我們的網站或應用。
他也可能很壞，使用一些爬蟲試圖拖垮我們的服務器。
所以怎麼實現呢？
本文使用 springboot，並將用戶的信息和訪問頻率記錄到 redis 中，如果你沒有使用 redis，也不影響，你可以參考着自己實現，比如存儲到內存或數據庫中。
想想這個需求，從第一性原理出發 用戶可能沒有登錄，或者已經登錄了。
如果用戶登錄了，我們就根據用戶名來限制，否則，就根據IP或者其它設備碼來限制，本文假設使用IP。
我們希望它足夠簡單，可以在多個方法上使用，而不需要編寫額外的代碼。所以我們要使用接口切面。
接口 1public @interface RequestRateLimit { 2 3	/** 4	* 限流的key，比如限制用戶註冊，限制用戶發送郵件，等等，一般是方法名 5	* @return 6	*/ 7	String key() default &amp;#34;&amp;#34;; 8 9	/** 10	* 限流模式,默認單機 11	* @return 12	*/ 13	RateType type() default RateType.PER_CLIENT; 14 15	/** 16	* 限流速率，1次/分鐘 17	* @return 18	*/ 19	long rate() default 1; 20 21	/** 22	* 限流速率，每分鐘 23	* @return 24	*/ 25	long rateInterval() default 60 * 1000; 26 27	/** 28	* 限流速率單位 29	* @return 30	*/ 31	RateIntervalUnit timeUnit() default RateIntervalUnit.</description></item><item><title>Oauth2 限制登錄一個客戶端</title><link>https://travisbikkle.github.io/zh-hant/2024/07/oauth2-single-login/</link><pubDate>Fri, 19 Jul 2024 10:20:30 +0800</pubDate><guid>https://travisbikkle.github.io/zh-hant/2024/07/oauth2-single-login/</guid><description>有時候我們希望用戶只能在一臺設備登錄賬號（我們太吝嗇了）。
使用 springboot oauth2 怎麼實現呢？
注意本文不會帶你使用 spring security 實現 oauth2 登錄，僅僅是討論我們那個吝嗇的需求。
假設我們有這樣一個自定義的認證實現類：
1public class RedisOAuth2AuthorizationService implements OAuth2AuthorizationService { 2 3	private final static Long TIMEOUT = 10L; 4 5	private static final String AUTHORIZATION = &amp;#34;token&amp;#34;; 6 7	private final RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate; 8 9	@Override 10	public void save(OAuth2Authorization authorization) { 11 // is refresh token mode or code mode 12 // ... 13 // is access token mode 14	if (isAccessToken(authorization)) { 15	OAuth2AccessToken accessToken = authorization.</description></item><item><title>獲取用戶真實IP</title><link>https://travisbikkle.github.io/zh-hant/2024/07/get-user-real-ip/</link><pubDate>Mon, 15 Jul 2024 10:20:57 +0800</pubDate><guid>https://travisbikkle.github.io/zh-hant/2024/07/get-user-real-ip/</guid><description>這是一個非常簡單的問題，但是在信息傳播過程中，發生了一些錯誤。
比如一些人會說，你配置 X-Real-Ip 啊，這樣就行了。
或者有些人會問，X-Real-Ip 和 X-Forward-For 有什麼區別，原理是什麼？
儼然是把 X-Real-Ip 給誤解了。
本文帶你看看，到底什麼是 X-Real-Ip。
快速回答 X-Real-Ip 什麼也不是。你可以使用 My-Real-Ip，His-Real-Ip，隨便什麼字符串。
1server { 2 ... 3 location / { 4 ... 5 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 6 proxy_set_header Host $host; 7 proxy_set_header His-Real-Ip2 $remote_addr; 8 } 9} 以上配置設置了三個請求頭，分別是 X-Forwarded-For、Host、His-Real-Ip2，後臺 java 服務端可以根據 His-Real-Ip2 獲取真實的 IP。
聽起來很傷人，可是 X-Real-Ip 真的只是看起來是官方的、某個隱藏的字段，實際上它並不是。
不要再問什麼 X-Real-Ip 的原理是什麼？ 或者 特殊的請求頭 X-Real-Ip 這樣的問題了，實際上真正的值，是 nginx 的內置變量 $remote_addr。
Docker 中的 nginx docker 中的 nginx 可以獲取到的 $remote_addr，可能是 172.</description></item></channel></rss>