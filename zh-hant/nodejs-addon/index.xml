<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nodejs addon on 奇风岁月</title><link>https://travisbikkle.github.io/zh-hant/nodejs-addon/</link><description>Recent content in nodejs addon on 奇风岁月</description><generator>Hugo -- gohugo.io</generator><language>zh-hant</language><copyright>Copyright © 2022-{year} Travis Bikkle. All Rights Reserved.</copyright><lastBuildDate>Tue, 23 Apr 2024 18:21:53 +0800</lastBuildDate><atom:link href="https://travisbikkle.github.io/zh-hant/nodejs-addon/index.xml" rel="self" type="application/rss+xml"/><item><title>在 webapck+electron+typescript中使用go開發的node插件</title><link>https://travisbikkle.github.io/zh-hant/2024/04/2024-04-23-webpack-electron-node-addon/</link><pubDate>Tue, 23 Apr 2024 18:21:53 +0800</pubDate><guid>https://travisbikkle.github.io/zh-hant/2024/04/2024-04-23-webpack-electron-node-addon/</guid><description>node 插件，electron 和 webpack 那些事 首先要明確在哪裏引入 node 的插件， main，preload還是 renderer？ 我們開發了一個 node 的插件，需要在 electron 中引入。我們一開始當然是希望在 renderer 中引入，畢竟最接近業務邏輯，省事。
不過會遇到報錯 &amp;lsquo;require is not defined&amp;rsquo;，也就是沒有 require 函數。
這個時候網上可能有些回答會讓你在 main.ts 中打開 nodeIntegration：
1mainWindow = new BrowserWindow({ 2 height: 800, 3 width: 1280, 4 maxHeight: 2160, 5 webPreferences: { 6 nodeIntegration: true, 7 devTools: nodeEnv.dev, 8 preload: path.join(__dirname, &amp;#39;./preload.bundle.js&amp;#39;), 9 }, 10}); 實際上這是不推薦的，爲什麼要在 renderer 中允許執行本地的命令，如 fs 等等？如果是一個惡意的網站，他就能訪問你本機所有的文件。當然如果你確保自己的應用不訪問外部網站，也可以。
我們可以瞭解下比較安全的做法。
爲了解決這個問題，我花了整整一天的時間，我這個項目的技術棧是 TypeScript, Webpack 5, 並且需要引入一個 go 寫的 node 插件，現代 javascript 的buff 疊滿了屬於是，我這個後端開發感受到了前端滿滿的惡意了。 開發插件並在 node 中跑通不到兩小時，可是把這個插件放到 webpack + electron 中花了我整整 7 個小時。</description></item></channel></rss>