<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>operator pattern on 奇风岁月</title><link>https://travisbikkle.github.io/operator-pattern/</link><description>Recent content in operator pattern on 奇风岁月</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><lastBuildDate>Thu, 26 May 2022 11:24:26 +0800</lastBuildDate><atom:link href="https://travisbikkle.github.io/operator-pattern/index.xml" rel="self" type="application/rss+xml"/><item><title>如何写一个 K8s Operator</title><link>https://travisbikkle.github.io/2022/05/operator-dev/</link><pubDate>Thu, 26 May 2022 11:24:26 +0800</pubDate><guid>https://travisbikkle.github.io/2022/05/operator-dev/</guid><description>使用过 k8s 的同学可能执行过以下命令：
1kubectl edit sts myapp # 编辑一个名称为 myapp 的 StatefulSet 2kubectl describe sts myapp # 查看一个名称为 myapp 的 StatefulSet StatefulSet 是 k8s 定义的一种资源，类似的还有 Deployment、Job、ConfigMap 等。当你执行 edit 命令编辑这些资源后，k8s 会通过不停轮询的方式（核心概念：control loop），将目标资源调整（核心概念：reconcile）到你期望的状态。
例如，你按了空调的遥控器，希望将房间的温度下调到 20℃。空调的压缩机开始工作，并且同时不停的检测当前实际的温度与你期望的温度之间的差异，直到温度达到20℃，这就是一个 control loop 的例子。
很简单，对吧？
设想一下如果不是这样，你将一手拿着温度计，然后不停的告诉空调温度仍然很高，或者已经变得过低了。
这就是声明式 API 的好处，用户只需要告诉程序你的期望，剩下的交给程序来做（对于程序开发者来说是雷锋行为），而程序实现目标最省力的方式，就是采用 control loop 的方式，不停的对比期望与现实的差距。
Operator 是什么 试想我们不再满足于 k8s 提供的默认的资源，我们想利用这种省心省力的方式，来管理我们自己的资源，如：数据库的一个用户。
你可能想说，数据库的用户存在于数据库内，我知道数据库的集群可以定义为 StatefulSet 然后由 k8s 管理，用户又怎么使用 k8s 管理呢？为什么要用 k8s 来管理呢？
为什么要用 k8s 管理用户资源？
以 MySql 为例，通常我们创建用户，是使用 root 用户登录到数据库，执行 sql 语句创建用户。但是设想以下几种场景：
你不知道 root 用户的密码，或者因为安全要求，不能提供给你 你不知道 MySql 的 IP 你知道以上信息，但是因为没有开启相应的节点权限，你无法登录数据库 你完成了以上所有步骤，结果其中某些登录或者创建步骤失败了，你和数据库运维人员开始扯皮 看到了吧？这些都是生产环境中，真实会遇到的事情。而使用以下步骤，我们就可以一举解决这些问题。</description></item></channel></rss>