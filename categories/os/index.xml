<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OS on 奇风岁月</title><link>https://travisbikkle.github.io/categories/os/</link><description>Recent content in OS on 奇风岁月</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>Copyright © 2022-{year} Travis Bikkle. All Rights Reserved.</copyright><lastBuildDate>Fri, 23 Aug 2024 17:32:12 +0800</lastBuildDate><atom:link href="https://travisbikkle.github.io/categories/os/index.xml" rel="self" type="application/rss+xml"/><item><title>OS 开发备忘3</title><link>https://travisbikkle.github.io/2024/08/osdev-memo3/</link><pubDate>Fri, 23 Aug 2024 17:32:12 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/osdev-memo3/</guid><description>多任务 Preemptive Multitasking 抢占式多任务 核心思想是操作系统控制什么时候切换任务。
第一行中，CPU 正在执行程序 A 的任务 A1。在第二行中，CPU 收到一个硬件中断。如硬件中断一文所述， CPU 会立即停止执行任务 A1，并跳转到中断描述符表 (IDT) 中定义的中断处理程序。通过该中断处理程序， 操作系统现在可以再次控制 CPU，从而切换到任务 B1，而不是继续执行任务 A1。
保存状态 由于任务会在任意时间点被中断，它们可能正在进行某些计算。为了能在稍后恢复任务，操作系统必须备份任务的整个状态， 包括其调用堆栈（call stack）和所有 CPU 寄存器（cpu register）的值。这个过程称为上下文切换（context switch）。
由于调用堆栈可能非常庞大，操作系统通常会为每个任务建立单独的调用堆栈，而不是在每个任务切换时备份调用堆栈内容。 这种拥有自己堆栈的任务称为执行线程（thread of execution），简称线程（thread）。 通过为每个任务使用单独的堆栈，在上下文切换时只需保存寄存器内容（包括程序计数器和堆栈指针）。 这种方法最大限度地减少了上下文切换的性能开销，这一点非常重要，因为上下文切换通常每秒会发生 100 次。
优缺点 优点：
操作系统保证 cpu 分配时间公平 缺点：
每个程序需要保存单独的 stack，浪费内存 操作系统需要为每次切换保存 cpu register 状态，即使任务只用了很少一部分 register Cooperative Multitasking 协作式多任务 核心思想是程序可以主动交出 cpu 控制权。
保存状态 由于任务自己定义暂停点，因此它们不需要操作系统来保存状态。 相反，它们可以在自己暂停之前准确保存继续运行所需的状态，这通常会带来更好的性能。 例如，Rust 的 async/await 实现会将所有仍需使用的局部变量存储在自动生成的结构体中（见下文）。
通过在暂停前备份调用栈的相关部分，所有任务都可以共享一个调用栈，从而大大降低了每个任务的内存消耗。这样就可以创建几乎任意数量的任务，而不会耗尽内存。
优缺点 优点：
性能高 缺点：
一些任务可能占有全部资源，其它任务获取不到 cpu 时间 rust 中的 async/await Future Future 代表一个现在还不能用的值。</description></item><item><title>OS 开发备忘2</title><link>https://travisbikkle.github.io/2024/08/osdev-memo2/</link><pubDate>Tue, 20 Aug 2024 17:32:12 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/osdev-memo2/</guid><description>实现堆内存 本地变量与栈内存 outer 方法调用 inner 方法的栈，从上至下。 inner 方法执行完成后。 静态变量 静态变量存储在独立于堆栈的固定内存位置。
该内存位置在编译时由链接器分配，并在可执行文件中编码。
动态内存 本地变量只生存于作用域内，静态变量全局可用、不能够回收、所有权不清晰。
两者都有一个固定的大小，所以无法存储会动态增长的变量。
为了解决这些问题，编程语言都会引入第三块内存区域： heap。
假设使用 allocate 和 deallocate 来分配和释放内存：
在调用 deallocate 之后，内存变成如下图所示：
所以相对于静态变量来说，z[1] 这块内存区域，我们可以复用。
但是 z[0] 和 z[2] 永远不释放，这就造成了内存泄漏。
其它错误 除了内存泄漏，但它并不会使我们的程序更易受到攻击，还有两种类型的错误会有更严重的后果：
use-after-free: 在 deallocate 之后尝试使用这个变量，这种错误会导致无法预料的行为，经常被攻击者利用来执行任意代码。 double-free: 释放两次，可能会释放掉一个在 deallocate 之后又重新分配的地址，也有可能导致 use-after-free 问题。 即使是最好的程序员，也无法永远不出错误地处理这些分配和释放流程，而且每年都会有新的错误， 比如可以在搜索引擎尝试搜索 use-after-free 2024，你可以把 2024 换成当年的年份。
为了解决这些问题，java 和 python 会使用垃圾回收机制，核心思想是，编码者无需手动写 allocate 和 deallocate，而是定时暂停、 扫描程序中未使用的堆变量，然后释放掉这些内存。这样，以上错误就不会再出现，缺点是定时扫描导致的性能开销，以及长时间的暂停。
rust 使用了不一样的解决方法：它使用所有权设计，来在编译时检查动态内存操作的正确性，于是rust消灭了垃圾回收，当然也就没有性能开销了。 另一个好处是，编码者仍然对内存拥有细粒度的控制，就像 C、C++，缺点就是你会有很多编译错误需要解决。
rust 中的分配 Rust 中最重要的类型之一是 Box，它其实是堆变量的封装，使用 Box::new 接收一个变量，执行 allocate 分配一个变量大小的区域，然后将变量 的值转移到堆中。要释放这块区域，Box 中还有 Drop 特质，它会调用 deallocate。</description></item><item><title>OS 开发备忘</title><link>https://travisbikkle.github.io/2024/08/osdev-memo/</link><pubDate>Wed, 07 Aug 2024 17:32:12 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/osdev-memo/</guid><description>显示（VGA TEXT MODE） 要在 VGA 文本模式下将字符打印到屏幕上，必须将其写入 VGA 硬件的文本缓冲区。 VGA 文本缓冲区是一个二维数组，通常有 25 行 80 列，可直接渲染到屏幕上。 每个数组条目通过以下格式描述一个屏幕字符： Bit(s) Value 0-7 ASCII 字符，8bit 8-11 前景色，4bit 12-14 背景色，3bit 15 闪烁，1bit 如何设计（伪代码）： 1#[derive(Debug, Clone, Copy, PartialEq, Eq)] 2#[repr(u8)] 3pub enum Color { 4 Black = 0, 5 Blue = 1, 6 Green = 2, 7 // 蓝绿 8 Cyan = 3, 9 Red = 4, 10 // 洋红 11 Magenta = 5, 12 Brown = 6, 13 LightGray = 7, 14 DarkGray = 8, 15 .</description></item></channel></rss>