<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Language Basic on 奇风岁月</title><link>https://travisbikkle.github.io/categories/language-basic/</link><description>Recent content in Language Basic on 奇风岁月</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>Copyright © 2022-{year} Travis Bikkle. All Rights Reserved.</copyright><lastBuildDate>Thu, 15 Aug 2024 11:22:03 +0800</lastBuildDate><atom:link href="https://travisbikkle.github.io/categories/language-basic/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust 错误码 E0277</title><link>https://travisbikkle.github.io/2024/08/2024-08-15-e0277/</link><pubDate>Thu, 15 Aug 2024 11:22:03 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/2024-08-15-e0277/</guid><description>我遇到的错误 直接使用 Error，没有使用 dyn 1fn run(config: Config) -&amp;gt; Result&amp;lt;(), dyn std::error::Error&amp;gt; { 2 let contents = std::fs::read_to_string(config.file_path).expect( 3 ... 4 Ok(()) 官方解释，是你要求返回一个实现了某特质的对象，但是该对象并没有实现该特质。
You tried to use a type which doesn&amp;rsquo;t implement some trait in a place which expected that trait.
其实编译器给出的报错比较接近：
1error[E0277]: the size for values of type `(dyn std::error::Error + &amp;#39;static)` cannot be known at compilation time 2 --&amp;gt; src/main.rs:18:27 3 | 418 | fn run(config: Config) -&amp;gt; Result&amp;lt;(), dyn std::error::Error&amp;gt; { 5 | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn&amp;#39;t have a size known at compile-time 它说，dyn std::error::Error 的大小在编译器无法确定，因此我们可以使用 Box 包裹起来。</description></item><item><title>Rust 错误码 E0283</title><link>https://travisbikkle.github.io/2024/08/2024-08-15-e0283/</link><pubDate>Thu, 15 Aug 2024 11:22:03 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/2024-08-15-e0283/</guid><description>1let args = env::args().collect(); // error 编译器无法推断类型，要求提供类型注解。
错误代码示例:
1let x = &amp;#34;hello&amp;#34;.chars().rev().collect(); 该错误表明编译器无法推断出类型，或者可能有多个类型，需要额外的信息。 在大多数情况下可以通过添加类型注解来提供。有时您需要手动指定一个通用类型参数。
一个常见的例子是 Iterator 上的 collect 方法。它有一个通用类型 参数，对于一个 char 迭代器来说，该参数是由 Vec 和 Name 实现的。 和 String 等实现。请看以下将字符串中的字符反转的示例:
在第一个代码示例中，编译器无法推断出 x 的类型应该是应该是什么类型: Vec&amp;lt;char&amp;gt;和String都是合适的候选类型。要指定使用哪种类型，可以在 x 上使用类型注解:
1let x: Vec&amp;lt;char&amp;gt; = &amp;#34;hello&amp;#34;.chars().rev().collect(); 无需注释完整类型。一旦解决了模棱两可的问题，编译器就能推断出其余部分:
1let x: Vec&amp;lt;_&amp;gt; = &amp;#34;hello&amp;#34;.chars().rev().collect(); 另一种为编译器提供足够信息的方法是指定通用类型参数:
1let x = &amp;#34;hello&amp;#34;.chars().rev().collect::&amp;lt;Vec&amp;lt;char&amp;gt;&amp;gt;(); 同样，如果编译器能推断出完整类型，则无需指定:
1let x = &amp;#34;hello&amp;#34;.chars().rev().collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;(); 我们可以看到下面一个独立的示例:
1struct Foo; 2 3impl Into&amp;lt;u32&amp;gt; for Foo { 4 fn into(self) -&amp;gt; u32 { 1 } 5} 6 7let foo = Foo; 8let bar: u32 = foo.</description></item><item><title>Rust 错误码 E0507</title><link>https://travisbikkle.github.io/2024/08/2024-08-15-e0507/</link><pubDate>Thu, 15 Aug 2024 11:22:03 +0800</pubDate><guid>https://travisbikkle.github.io/2024/08/2024-08-15-e0507/</guid><description>1	let args: Vec&amp;lt;_&amp;gt; = env::args().collect(); 2	let query = args[1]; // error move = take ownership = 取得所有权。
borrow = don't take ownership = 借用。
move 常见案例 1// _Stack_ 分配的变量 2let x = 5u32; 3// *Copy* `x` 到 `y` - 所有权未发生转移，未发生 move 4let y = x; 5// 两个变量可以同时使用 6println!(&amp;#34;x is {}, and y is {}&amp;#34;, x, y); 7 8// `a` 是指向 _heap_ 上分配的变量的 pointer 9let a = Box::new(5i32); 10 11println!</description></item></channel></rss>